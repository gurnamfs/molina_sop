import os
import yaml
import difflib
from pprint import pp as print
from langchain_community.agent_toolkits import JsonToolkit, create_json_agent
from langchain_community.tools.json.tool import JsonSpec
from langchain_core.tools import tool
from langgraph.prebuilt import create_react_agent
from prompts import prefix, suffix, sys, system_message
from langchain_openai import AzureChatOpenAI
from functions import llm

import logging

logging.basicConfig(level=logging.DEBUG,  # Set log level to debug to capture all types of logs
                    format='%(asctime)s - %(levelname)s - %(message)s',
                    handlers=[logging.FileHandler("guide_tool.log"), logging.StreamHandler()])

model = AzureChatOpenAI(
    azure_endpoint="https://firstsenseai.openai.azure.com",
    azure_deployment="gpt-4o",
    api_version="2024-02-15-preview",
    api_key="a823ef8205364125a194795f870da84c",
    temperature=0,
    max_tokens=None,
)

@tool
def create_agent(file_path: str, query: str) -> str:
    """
    Create an agent to extract relevant information from a specified document.
    This function initializes an agent with the document located at the given
    file path and processes the query to extract information related
    to it. The agent will analyze the content of the document to identify
    relevant responses based on the query.

    Args:
        file_path (str): The path to the document file that the agent will analyze.
        query (str): The query to be processed by the agent.

    Returns:
        str: The response generated by the agent based on the provided query.
             This may include relevant information or references from the document.
    """
    logger.debug("##### CREATE AGENT TOOL #####")
    logger.debug(f"File Name: {file_path}, Claim: {query}")

    try:
        # Read the data from the file
        with open(file_path, "r", encoding="utf-8") as f:
            data = yaml.load(f, Loader=yaml.FullLoader)
        logger.info(f"Successfully loaded data from {file_path}")

        json_spec = JsonSpec(dict_=data, max_value_length=4000)
        json_toolkit = JsonToolkit(spec=json_spec)
        
        logger.debug("JsonSpec and JsonToolkit initialized successfully")

        json_agent_executor = create_json_agent(
            handle_parsing_errors=True,
            prefix=prefix,
            suffix=suffix,
            llm=llm,
            toolkit=json_toolkit,
            verbose=True,
        )

        logger.debug("JsonAgentExecutor created successfully")

        # Perform the query and capture the response
        response = json_agent_executor.invoke(
            query
            + "\n\nNote: Return the final answer in a readable format without adding any information."
        )
        
        logger.info("Create Agent executed successfully")
        return response

    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        raise
    except yaml.YAMLError as e:
        logger.error(f"Error reading YAML file {file_path}: {e}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise


@tool
def get_file_path(query: str) -> str:
    """
    Use this function when "Refer to the..." in the Answer."

    Args:
        query (str): Answer that contains a reference to a document.

    Returns:
        str: The file path of the document being referenced.
    """
    logger.debug("### GET FILE NAME TOOL ###")
    logger.debug(f"Query: {query}")
    
    try:
        directory_path = "json-files"
        # Find all JSON files in the directory
        json_files = [
            file
            for root, dirs, files in os.walk(directory_path)
            for file in files
            if file.endswith((".json"))
        ]
        logger.debug(f"Found {len(json_files)} JSON files in directory '{directory_path}'")

        normalized_text = query.lower()
        logger.debug(f"Normalized query: {normalized_text}")

        # Find the closest matching file based on the query
        closest_match = difflib.get_close_matches(normalized_text, json_files, n=1, cutoff=0.0)

        if closest_match:
            res = closest_match[0]
            logger.info(f"Closest match found: {res}")
            return f"json-files/{res}"
        else:
            logger.warning(f"No close match found for query: {query}")
            return "No File Found"
    
    except Exception as e:
        logger.error(f"Error occurred while processing the query '{query}': {e}")
        return str(e)


messages = []


@tool
def guide(query: str) -> str:
    """
    Always use this tool before returning the Final Answer.

    Args:
        query (str): A string containing the input or query about the claim.

    Returns:
        str: An instruction for the next tool usage.
    """
    logging.info("### Guide Tool Started ###")
    logging.debug(f"Query received: {query}")
    
    # Assuming messages is a list defined somewhere in the broader scope
    messages.append(("human", query))
    
    # Log the current state of messages after the query is appended
    logging.debug(f"Messages after human query: {messages}")
    
    # Generate the response
    ai_message = model.invoke(messages).content
    
    # Log the AI's response
    logging.debug(f"AI response: {ai_message}")
    
    messages.append(("ai", ai_message))
    
    # Log the state of messages after the AI's response is appended
    logging.debug(f"Messages after AI response: {messages}")
    
    logging.info("### Guide Tool Finished ###")
    return ai_message


tools = [guide, create_agent, get_file_path]

langgraph_agent_executor = create_react_agent(llm, tools, state_modifier=system_message)
